# 기능상세명세서

## ✅ [1] 대시보드 화면 (`DashboardScreen`) - 구현 완료

### 🔹 구현된 기능

- 로그인한 사용자의 만다라트 리스트 불러오기
- 새로운 만다라트 생성
- 각 만다라트 카드 클릭 시 편집 화면으로 이동 (라우팅 구현)
- 빈 상태(Empty State) 표시
- 토스트 메시지로 피드백 제공

### 🔸 구현된 UI 컴포넌트

| 컴포넌트 | 설명 | 구현 상태 |
| --- | --- | --- |
| `HeaderBar` | 사용자 이름, 로그아웃 버튼 | ✅ |
| `MandalartCard` | 제목, 생성일, 수정일 표시 (Touchable) | ✅ |
| `NewMandalartButton` | `+ 새 만다라트 만들기` 버튼 | ✅ (`Button` 컴포넌트 사용) |
| `NewMandalartModal` | 새 만다라트 생성 모달 | ✅ |
| `EmptyState` | 데이터 없을 때 안내 표시 | ✅ |
| `Toast` | 성공/에러 메시지 표시 | ✅ (추가 구현) |
| `UseTemplateButton` | `템플릿에서 시작하기` | ✅ (기본 구현) |
| `SearchInput` | 검색 입력 필드 | ⬜ (향후 구현 예정) |
| `TagFilter` | 태그별 필터 기능 | ⬜ (향후 구현 예정) |

### 🔹 API 구현 내용 (Supabase 연동)

| API 기능 | 설명 | 구현 상태 |
| --- | --- | --- |
| `fetchMandalartList` | 사용자의 만다라트 목록 조회 | ✅ |
| `createMandalart` | 새 만다라트 생성 (일반/템플릿 기반) | ✅ |
| `deleteMandalart` | 만다라트 삭제 | ✅ |

---

## ✅ [2] 만다라트 편집 화면 (`MandalartEditorScreen`) - 구현 완료

### 🔹 구현된 기능

- 9×9 전체 격자 구성 (`MandalartGrid`, `MandalartCell`)
- 텍스트, 색상 표시
- 칸 클릭 기능
- 데이터 로드 및 저장 (Supabase 연동)

### 🔸 구현된 UI 컴포넌트

| 컴포넌트 | 설명 | 구현 상태 |
| --- | --- | --- |
| `MandalartGrid` | 전체 9×9 격자 표시 | ✅ |
| `MandalartCell` | 각 셀 컴포넌트 (텍스트, 색상) | ✅ |
| `HighlightedCenterBlock` | 중앙 3×3 강조 스타일 적용 | ✅ |
| `HeaderBar` | 공통 헤더 컴포넌트 재사용 | ✅ |
| `CellClickHandler` | 각 칸 탭 이벤트 | ✅ |
| 페이지 라우팅 | `/mandalart/[id]` | ✅ |

### 🔹 API 구현 내용 (Supabase 연동)

| API 기능 | 설명 | 구현 상태 |
| --- | --- | --- |
| `fetchMandalart` | 만다라트 데이터 조회 (81개 셀 포함) | ✅ |
| `updateCell` | 셀 내용 업데이트 | ✅ |
| `createCell` | 새 셀 생성 | ✅ |
| `toggleCellCompletion` | 셀 완료 상태 토글 | ✅ |

---

## ✅ [3] 칸 편집 슬라이드업 (`CellEditorForm`) - 구현 완료

### 🔹 구현된 기능

- 주제 입력 (10자 제한)
- 메모 입력
- 색상 선택 (고정 팔레트)
- 저장 기능

### 🔸 구현된 UI 컴포넌트

| 컴포넌트 | 설명 | 구현 상태 |
| --- | --- | --- |
| `SlideUpPanel` | 하단에서 등장하는 슬라이드업 UI | ✅ |
| `TopicInput` | 단일행 입력창, 10자 제한 | ✅ (`InputField` 재사용) |
| `MemoTextarea` | 다중행 입력 | ✅ (`TextArea` 재사용) |
| `ColorPalette` | 원형 색상 선택 컴포넌트 | ✅ |
| `SaveButton` | 변경 내용 저장 후 슬라이드 닫기 | ✅ (`Button` 재사용) |
| `ImageUpload` | 이미지 업로드 기능 | ⬜ (향후 구현 예정) |

### 🔹 데이터 처리 구현

| 기능 | 설명 | 구현 상태 |
| --- | --- | --- |
| `updateCell` | Supabase DB에 셀 데이터 저장 | ✅ |
| 유효성 검증 | 주제 길이 제한 | ✅ |
| 실시간 UI 반영 | 저장 시 그리드 UI 갱신 | ✅ |

---

## ✅ [4] 새 만다라트 생성 팝업 (`NewMandalartModal`) - 구현 완료

### 🔹 구현된 기능

- 제목 입력
- 템플릿 선택 기능 (기초 구현)
- 생성 버튼 → 편집 화면으로 이동

### 🔸 구현된 UI 컴포넌트

| 컴포넌트 | 설명 | 구현 상태 |
| --- | --- | --- |
| `ModalContainer` | 중간에 뜨는 팝업 형태 | ✅ |
| `TitleInput` | 만다라트 제목 입력 | ✅ (`InputField` 재사용) |
| `TemplateSelector` | 템플릿 선택 기능 | ✅ (기본 구현) |
| `ConfirmButton` | 새 만다라트 생성 | ✅ (`Button` 재사용) |

### 🔹 API 구현 내용 (Supabase 연동)

| API 기능 | 설명 | 구현 상태 |
| --- | --- | --- |
| `createMandalart` | 빈 만다라트 생성 | ✅ |
| `duplicate_mandalart_from_template` | 템플릿 기반 복제 | ✅ |

---

## 🔧 공통으로 구현된 재사용 컴포넌트

| 컴포넌트 | 설명 | 구현 상태 |
| --- | --- | --- |
| `Button` | 다양한 스타일의 버튼 (Primary, Secondary 등) | ✅ |
| `InputField` | 단일행 텍스트 입력 필드 | ✅ |
| `TextArea` | 메모용 다중행 입력 필드 | ✅ |
| `ColorPalette` | 색상 선택용 팔레트 | ✅ |
| `ModalContainer` | 팝업 컴포넌트 | ✅ |
| `SlideUpPanel` | 하단 슬라이드 컴포넌트 | ✅ |
| `Toast` | 저장 완료, 오류 메시지 등 간단 알림 표시 | ✅ |
| `MobileLayout` | 모바일 레이아웃 컴포넌트 | ✅ |

---

## 📚 Supabase 데이터베이스 연동 (구현 완료)

### 🔹 테이블 구조 

| 테이블 | 설명 | 구현 상태 |
| --- | --- | --- |
| `mandalarts` | 만다라트 목록 (제목, 소유자 등) | ✅ |
| `mandalart_cells` | 각 셀 데이터 (position, topic, memo 등) | ✅ |

### 🔹 데이터 변환 유틸리티

| 유틸리티 | 설명 | 구현 상태 |
| --- | --- | --- |
| `mapPositionToBlockAndCell` | 포지션(0-80)을 블록/셀 인덱스로 변환 | ✅ |
| `mapBlockAndCellToPosition` | 블록/셀 인덱스를 포지션으로 변환 | ✅ |
| `convertDbCellsToMandalart` | DB 데이터를 프론트엔드 모델로 변환 | ✅ |

---

## 📊 추가 구현 필요 기능

1. **이미지 업로드**: 셀 내 이미지 추가 기능
2. **상세 템플릿 기능**: 다양한 템플릿 적용 및 미리보기
3. **검색 및 필터링**: 대시보드에서 만다라트 검색 및 필터링
4. **데이터 동기화**: 자동 저장 및 실시간 업데이트

## 만다라트 무한 뎁스 구조 개선 계획

현재 만다라트는 고정된 3x3(또는 9x9) 구조로 제한되어 있습니다. 무한 뎁스를 지원하는 부모-자식 구조로 변경하기 위한 계획을 세워보겠습니다.

## 1. 데이터 모델 변경 (계층 구조화)

### 1-1. 새로운 DB 스키마

```sql
CREATE TABLE mandalart_cells (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  mandalart_id UUID REFERENCES mandalarts(id) ON DELETE CASCADE,
  parent_id UUID REFERENCES mandalart_cells(id) ON DELETE CASCADE NULL,
  position INT NOT NULL,
  depth INT NOT NULL DEFAULT 0,
  topic TEXT,
  memo TEXT,
  image_url TEXT,
  color TEXT,
  is_completed BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- 인덱스 추가
CREATE INDEX idx_parent_id ON mandalart_cells(parent_id);
CREATE INDEX idx_depth ON mandalart_cells(depth);
```

### 1-2. TypeScript 타입 정의 변경

```typescript
export interface MandalartCell {
  id: string;
  topic: string;
  memo?: string;
  color?: string;
  imageUrl?: string;
  isCompleted?: boolean;
  parentId?: string | null;
  depth: number;
  position: number;
  children?: MandalartCell[]; // 하위 셀 참조
}

// 블록 개념은 삭제하고 중첩 셀 구조로 변경
export interface Mandalart {
  id: string;
  title: string;
  createdAt: string;
  updatedAt: string;
  rootCell: MandalartCell; // 최상위 셀
}
```

## 2. 컴포넌트 구조 변경

### 2-1. MandalartGrid 컴포넌트 수정

```tsx
const MandalartGrid: React.FC<MandalartGridProps> = ({
  cell, // 현재 표시할 셀 (하위 셀 9개 포함)
  onCellClick,
  isExpanded = false,
  className = '',
  depth = 0, // 현재 깊이
  onNavigateBack, // 상위 셀로 이동
}) => {
  // 셀의 하위 셀 9개를 3x3 그리드로 표시하는 로직
  // 셀 클릭 시 하위 셀로 이동하는 로직
};
```

### 2-2. 네비게이션 경로 표시 (Breadcrumb)

```tsx
const MandalartNavigation: React.FC<{
  path: MandalartCell[]; // 현재까지의 경로
  onNavigate: (cellId: string) => void;
}> = ({ path, onNavigate }) => {
  return (
    <div className="flex items-center space-x-2 overflow-x-auto">
      {path.map((cell, index) => (
        <React.Fragment key={cell.id}>
          {index > 0 && <span className="text-gray-400">/</span>}
          <button 
            onClick={() => onNavigate(cell.id)}
            className="text-sm hover:underline"
          >
            {cell.topic || '무제'}
          </button>
        </React.Fragment>
      ))}
    </div>
  );
};
```

## 3. 페이지 로직 개선

### 3-1. 셀 네비게이션 로직

```tsx
export default function MandalartEditorPage() {
  // ...기존 코드...
  const [currentCellId, setCurrentCellId] = useState<string | null>(null);
  const [navigationPath, setNavigationPath] = useState<MandalartCell[]>([]);
  
  // 셀 클릭 시 하위 셀로 이동
  const handleCellClick = (cellId: string) => {
    // 1. 하위 셀이 있는지 확인
    const hasChildren = checkHasChildren(cellId);
    
    if (hasChildren) {
      // 하위 셀로 이동 (네비게이션)
      setCurrentCellId(cellId);
      updateNavigationPath(cellId);
    } else {
      // 하위 셀 없으면 에디터 열기
      openCellEditor(cellId);
    }
  };
  
  // 상위 셀로 이동
  const handleNavigateBack = () => {
    if (navigationPath.length > 1) {
      const parentCell = navigationPath[navigationPath.length - 2];
      setCurrentCellId(parentCell.id);
      setNavigationPath(prev => prev.slice(0, -1));
    }
  };
  
  // 특정 셀로 직접 이동
  const handleNavigateTo = (cellId: string) => {
    const index = navigationPath.findIndex(cell => cell.id === cellId);
    if (index >= 0) {
      setCurrentCellId(cellId);
      setNavigationPath(prev => prev.slice(0, index + 1));
    }
  };
}
```

## 4. 인터페이스 구조 개선

### 4-1. 셀 클릭 vs 메모 편집 인터페이스 분리

```tsx
const MandalartCell: React.FC<MandalartCellProps> = ({
  cell,
  onClick,
  onEdit,
  className = '',
}) => {
  return (
    <div className={`relative ${className}`}>
      <div
        className="w-full h-full rounded p-1 cursor-pointer"
        onClick={onClick} // 셀 클릭 시 하위 셀로 이동
        style={{ backgroundColor: cell.color }}
      >
        <div className="text-xs">{cell.topic || '클릭하여 입력'}</div>
      </div>
      
      {/* 편집 버튼 - 별도로 메모와 속성 편집 */}
      <button
        className="absolute top-0 right-0 w-6 h-6 bg-white rounded-full shadow opacity-80 hover:opacity-100"
        onClick={(e) => {
          e.stopPropagation(); // 클릭 이벤트 전파 방지
          onEdit();
        }}
      >
        <svg /* 편집 아이콘 */></svg>
      </button>
    </div>
  );
};
```

## 5. 데이터 로드 및 저장 로직 변경

### 5-1. 계층 구조 로드

```typescript
const fetchCellWithChildren = async (mandalartId: string, cellId: string | null = null, depth: number = 0) => {
  const supabase = createClient();
  let query = supabase
    .from('mandalart_cells')
    .select('*');
    
  if (cellId === null) {
    // 최상위 셀 로드
    query = query.eq('mandalart_id', mandalartId)
                 .eq('parent_id', null)
                 .eq('depth', 0);
  } else {
    // 하위 셀 로드
    query = query.eq('mandalart_id', mandalartId)
                 .eq('parent_id', cellId);
  }
  
  const { data, error } = await query;
  
  if (error) throw error;
  
  return data;
};
```

### 5-2. 새 셀 생성 로직

```typescript
const createChildCells = async (mandalartId: string, parentId: string, depth: number) => {
  const supabase = createClient();
  
  // 8개의 빈 하위 셀 생성
  const cells = Array(8).fill(0).map((_, index) => ({
    mandalart_id: mandalartId,
    parent_id: parentId,
    position: index,
    depth: depth + 1,
    topic: '',
  }));
  
  const { data, error } = await supabase
    .from('mandalart_cells')
    .insert(cells)
    .select();
    
  if (error) throw error;
  
  return data;
};
```

## 구현 단계

1. **DB 스키마 변경**: parent_id와 depth 필드 추가
2. **모델 변환 유틸리티**: 기존 데이터를 새 구조로 마이그레이션
3. **UI 컴포넌트 개발**: 네비게이션, 계층 구조 표시
4. **상태 관리 로직 개선**: 현재 경로 및 뎁스 관리
5. **편집/탐색 인터페이스 분리**: 셀 클릭 → 하위 셀 탐색, 편집 버튼 → 속성 편집

이러한 변경을 통해 만다라트를 무한 뎁스 구조로 확장하고, 사용자가 보다 복잡한 계획과 아이디어를 구조화할 수 있게 할 수 있습니다.